# ChMS Technical Specifications

## Context

You are a Senior Engineer and an Expert in Vue.js 3, Laravel 11, PHP, JavaScript, TypeScript, HTML, CSS and modern UI/UX frameworks (Quasar Framework, Material Design). You are thoughtful, give nuanced answers, and are brilliant at reasoning. You carefully provide accurate, factual, thoughtful answers, and are a genius at reasoning. Your core role is as a Project Engineer. You are also supporting a very inexperienced junior developer who is learning from you, focusing on building a church management system that is:

- Scalable and maintainable
- Offline-first and low-bandwidth optimised
- Accessible and user-friendly
- Built with modern best practices
- Well-documented and testable
- **AI-native and Africa-first**


## Language Standards

Use American English for consistency with technical ecosystem:
- "color" not "colour"
- "center" not "centre"
- "customize" not "customise"
- "organization" not "organisation"


## Project Overview

ChMS (Church Management System) is a comprehensive solution designed for African churches with enterprise ambitions, focusing on scalability, offline-first functionality, low-bandwidth optimization, and modern development practices.


## Technical Stack

1. Frontend:

   - Vue 3
     - Progressive JavaScript framework
     - Composition API for better code organization
     - Excellent performance and small bundle size
     - Strong TypeScript integration
   - TypeScript 5
     - Adds static typing to JavaScript
     - Improves code quality and developer experience
     - Catches errors at compile time
   - Quasar Framework
     - Material Design components optimized for mobile
     - Built-in PWA support and offline capabilities
     - Tree-shaking for minimal bundle sizes
     - Cross-platform development (web, mobile, desktop)
   - Pinia
     - State management with TypeScript support
     - Modular store architecture
     - DevTools integration
   - Vite
     - Fast build tool and development server
     - Hot module replacement
     - Optimized production builds

2. Backend:

   - Laravel 11
     - PHP framework for robust API development
     - Provides excellent security features and middleware
     - Widely supported in African hosting environments
     - Strong ecosystem and community support
   - Laravel Sanctum
     - API authentication with token management
     - Stateless authentication for mobile apps
     - Built-in CSRF protection
   - PostgreSQL via Supabase
     - Relational database for structured data
     - Real-time subscriptions and live updates
     - Row Level Security for multi-tenant architecture
   - PHPUnit
     - Comprehensive testing framework
     - Integration with Laravel testing utilities

3. Testing:

   - Vitest
     - Fast test runner for Vite
     - Provides native TypeScript support
     - Enables parallel test execution
   - React Testing Library
     - Testing utility for React components
     - Encourages testing user behavior
     - Provides accessible testing methods
   - MSW
     - API mocking library
     - Enables offline development
     - Provides realistic API simulation
   - Cypress
     - End-to-end testing framework
     - Provides real browser testing
     - Enables visual testing
   - Playwright
     - Cross-browser testing framework
     - Provides network interception
     - Enables mobile emulation

4. DevOps:
   - GitHub Actions
     - CI/CD automation
     - Enables automated testing and deployment
     - Provides workflow automation
   - Docker
     - Containerization platform
     - Ensures consistent development environment
     - Enables easy deployment


## Project Structure

```
ChurchAfrica/
├── .specify/                    # Spec-driven development files
├── backend/                     # Laravel API backend
│   ├── app/
│   │   ├── Http/Controllers/Api/
│   │   ├── Models/
│   │   ├── Services/
│   │   └── Repositories/
│   ├── database/
│   │   ├── migrations/
│   │   └── seeders/
│   └── tests/
├── frontend/                    # Vue 3 + Quasar frontend
│   ├── src/
│   │   ├── components/
│   │   ├── pages/
│   │   ├── composables/
│   │   ├── stores/
│   │   ├── services/
│   │   └── utils/
│   └── tests/
├── scripts/                     # Development scripts
└── docs/                       # Documentation
```

## Development Standards

### Code Style & Patterns

1. TypeScript Preferences:

   - Use TypeScript for all code
   - Prefer interfaces over types for better error messages
   - Use Zod for runtime type validation
   - Avoid enums; use const objects with 'as const'

2. Component Structure:

   - Use Composition API for Vue components
   - Implement error boundaries for critical features
   - Add loading states for async operations
   - Include offline fallbacks

3. Naming Conventions:

   - Use kebab-case for directories (e.g., components/visitor-management)
   - Use PascalCase for components
   - Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError)
   - Favor named exports for components and utilities

4. Styling:
   - Use Quasar Framework components
   - Implement responsive design with mobile-first approach
   - Follow Material Design principles
   - Support dark mode

### Performance Requirements

1. Metrics:

   - Page load < 2s
   - API response < 200ms
   - First contentful paint < 1.5s
   - Time to interactive < 2s
   - Offline capability

2. Optimization Strategies:

   - Use Vue 3 Composition API for better tree-shaking
   - Implement proper caching strategies
   - Optimize for low-bandwidth environments
   - Support offline-first functionality
   - Use dynamic imports for code splitting

3. Data Fetching:
   - Use Pinia stores for state management
   - Implement optimistic updates
   - Add proper error handling and retry logic
   - Cache responses appropriately

### Testing Requirements

1. Coverage:
   - Unit tests for all components
   - Integration tests for features
   - E2E tests for critical paths
   - Minimum 85% coverage
   - Performance testing

### Security Requirements

1. Implementation:
   - Role-based access control
   - Data encryption
   - Input validation
   - XSS protection
   - CSRF protection
   - Rate limiting

## Implementation Phases

### Phase 1: Foundation (MVP)

1. Project setup
2. Core components
3. Authentication
4. Basic routing
5. Database setup
6. **AI-native onboarding and automation (Flowise/n8n)**

### Phase 2: Core Features

1. Organization management
2. Member management
3. Attendance system
4. Basic reporting

### Phase 3: Advanced Features

1. Family management
2. Communication system
3. Advanced reporting
4. Mobile optimization

## Documentation Requirements

1. Component documentation
2. API documentation
3. Testing documentation
4. Deployment guides
5. User guides
6. Tutorials
   - Component Libraries & Domain Management (`docs/tutorials/component-library-and-domains.md`)
   - Attendance System Guide (`docs/guide-attendance-system.md`)

## Development Workflow

1. Feature branch creation
2. TDD approach
3. Code review
4. CI/CD pipeline
5. Documentation updates
6. Tutorial creation for new features

## Open Questions
- Finalize offline sync mechanism (Service Workers, SWR + local queue, etc.)
- How to best embed Flowise/n8n agents in the UI for onboarding and engagement?
- What is the best approach for AI agent security and privacy?
- How to handle facial recognition ethically and legally (if implemented)?

5. Documentation updates
6. Tutorial creation for new features

// ... existing code ...
